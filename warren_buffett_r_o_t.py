# -*- coding: utf-8 -*-
"""Warren Buffett R.O.T

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1auPATEM4ZNOgks-POFv6zsocvET-SY3l
"""

# Buffett-style checklist using FREE Yahoo Finance via yfinance (no paid API)
# ---------------------------------------------------------------
# pip install yfinance pandas

import warnings
warnings.filterwarnings("ignore")
import pandas as pd
import yfinance as yf

# ------------ Settings ------------
TICKERS = ["AAPL", "NVDA", "META"]

THRESH = {
    "gross_margin_min": 0.40,
    "sga_margin_max":   0.30,
    "rnd_margin_max":   0.30,
    "depr_margin_max":  0.10,
    "interest_margin_max": 0.15,
    "tax_margin_low":   0.18,
    "tax_margin_high":  0.22,
    "net_margin_min":   0.20,
    "adj_de_to_eq_max": 0.80,
    "capex_margin_max": 0.25
}

# ------------ Helpers ------------
def safe_div(a, b):
    try:
        return (a or 0) / b if b not in (0, None, 0.0) else 0.0
    except Exception:
        return 0.0

def tick(ok): return "✓" if ok else "✗"
def fmt_pct(x): return f"{x:.2%}"
def fmt_billions(x): return f"{round((x or 0)/1_000_000_000, 1)}B"

def first_available(df, candidates):
    """Return the first matching row from df (annual statement DataFrame)."""
    for key in candidates:
        if key in df.index:
            return df.loc[key]
    # yfinance sometimes normalizes to camelCase row names:
    lower_index = {i.lower(): i for i in df.index}
    for key in candidates:
        k = key.lower()
        if k in lower_index:
            return df.loc[lower_index[k]]
    return pd.Series(dtype="float64")

def shares_two_years(inc, bs, info):
    """
    Try to get two-year EPS using (Net Income / Shares).
    Prefers 'Basic Average Shares' or 'Diluted Average Shares' from income stmt.
    Falls back to point-in-time sharesOutstanding for both years (not ideal).
    """
    # Prefer average shares from income statement
    basic = first_available(inc, ["Basic Average Shares", "BasicAverageShares", "Basic Shares"])
    diluted = first_available(inc, ["Diluted Average Shares", "DilutedAverageShares", "Diluted Shares"])
    shares = basic if not basic.empty else diluted

    if not shares.empty and len(shares) >= 2:
        s0 = shares.iloc[0]
        s1 = shares.iloc[1]
        return s0, s1

    # Fallback: point-in-time shares (same for both years)
    s = info.get("sharesOutstanding") or info.get("shares_outstanding")
    return s or 0, s or 0

def total_debt_from_bs(bs):
    td = first_available(bs, ["Total Debt", "TotalDebt"])
    if not td.empty:
        return td
    short = first_available(bs, ["Short Long Term Debt", "ShortLongTermDebt", "Short Term Debt"])
    long_  = first_available(bs, ["Long Term Debt", "LongTermDebt"])
    return (short.fillna(0) + long_.fillna(0)) if (not short.empty or not long_.empty) else pd.Series([0,0])

def cash_like_from_bs(bs):
    cashsti = first_available(bs, ["Cash And Short Term Investments", "CashAndShortTermInvestments"])
    if not cashsti.empty:
        return cashsti
    cash = first_available(bs, ["Cash And Cash Equivalents", "CashAndCashEquivalents"])
    return cash if not cash.empty else pd.Series([0,0])

# ------------ Core ------------
def compute_for_ticker(tkr):
    tk = yf.Ticker(tkr)

    # Annual statements (columns are periods sorted newest -> oldest)
    inc = tk.income_stmt   if hasattr(tk, "income_stmt")   else tk.financials
    bal = tk.balance_sheet if hasattr(tk, "balance_sheet") else tk.balance_sheet
    cfs = tk.cashflow      if hasattr(tk, "cashflow")      else tk.cashflow

    # Ensure we have data and at least 2 columns
    if inc is None or bal is None or cfs is None or inc.empty or bal.empty or cfs.empty:
        return None

    # Make sure newest->oldest and take two most recent columns
    inc = inc.iloc[:, :2]
    bal = bal.iloc[:, :2]
    cfs = cfs.iloc[:, :2]

    info = {}
    try:
        info = tk.fast_info if hasattr(tk, "fast_info") else tk.info
    except Exception:
        pass

    # ---- Income statement lines (two latest years) ----
    revenue       = first_available(inc, ["Total Revenue", "TotalRevenue", "Revenue"])
    gross_profit  = first_available(inc, ["Gross Profit", "GrossProfit"])
    sga           = first_available(inc, ["Selling General Administrative", "SellingGeneralAdministrative"])
    rnd           = first_available(inc, ["Research Development", "ResearchAndDevelopment"])
    dep_amort     = first_available(inc, ["Depreciation Amortization", "DepreciationAmortization"])
    op_income     = first_available(inc, ["Operating Income", "OperatingIncome"])
    int_exp       = first_available(inc, ["Interest Expense", "InterestExpense"])
    tax_exp       = first_available(inc, ["Income Tax Expense", "IncomeTaxExpense"])
    pre_tax       = first_available(inc, ["Income Before Tax", "IncomeBeforeTax", "Pretax Income", "PretaxIncome"])
    net_income    = first_available(inc, ["Net Income", "NetIncome"])

    # ---- Balance sheet lines ----
    total_liab    = first_available(bal, ["Total Liab", "TotalLiab", "Total Liabilities", "TotalLiabilities"])
    equity        = first_available(bal, ["Total Stockholder Equity", "TotalStockholderEquity", "Total Equity", "StockholdersEquity"])
    treasury      = first_available(bal, ["Treasury Stock", "TreasuryStock"])
    retained      = first_available(bal, ["Retained Earnings", "RetainedEarnings"])
    preferred     = first_available(bal, ["Preferred Stock", "PreferredStock"])
    total_debt    = total_debt_from_bs(bal)
    cash_like     = cash_like_from_bs(bal)

    # ---- Cash flow lines ----
    capex         = first_available(cfs, ["Capital Expenditures", "CapitalExpenditures", "Capital Expenditure"])

    # Use most recent column index 0, prior year index 1
    def val(s, i=0):
        try: return float(s.iloc[i])
        except Exception: return 0.0

    # Income statement ratios (current year)
    gp0, rev0 = val(gross_profit,0), val(revenue,0)
    gm = safe_div(gp0, rev0)

    sga0 = val(sga,0)
    sga_m = safe_div(sga0, gp0)

    rnd0 = val(rnd,0)
    rnd_m = safe_div(rnd0, gp0)

    dep0 = val(dep_amort,0)
    dep_m = safe_div(dep0, gp0)

    op0  = val(op_income,0)
    int0 = val(int_exp,0)
    int_m = safe_div(int0, op0)

    tax0 = val(tax_exp,0)
    pret0 = val(pre_tax,0)
    tax_m = safe_div(tax0, pret0)

    net0 = val(net_income,0)
    net_m = safe_div(net0, rev0)

    # EPS using shares
    s0, s1 = shares_two_years(inc, bal, info)
    eps0 = safe_div(net0, s0)
    net1 = val(net_income,1)
    eps1 = safe_div(net1, s1)
    eps_ok = (eps0 > eps1) and (eps0 > 0)

    # Balance sheet checks (current year)
    cash0 = val(cash_like,0)
    debt0 = val(total_debt,0)
    cash_ok = cash0 > debt0

    liab0 = val(total_liab,0)
    eq0   = val(equity,0)
    tre0  = val(treasury,0)  # may be negative
    adj_eq0 = eq0 + tre0
    adj_de = safe_div(liab0, adj_eq0) if adj_eq0 else float("inf")
    adj_ok = adj_de < THRESH["adj_de_to_eq_max"]

    pref0 = val(preferred,0)
    pref_ok = pref0 == 0

    re0 = val(retained,0); re1 = val(retained,1)
    re_ok = re0 > re1 if (re0 and re1) else False

    tre_ok = abs(tre0) > 1

    # Cash flow (current year)
    capex0 = abs(val(capex,0))
    capex_m = safe_div(capex0, net0)
    capex_ok = capex_m < THRESH["capex_margin_max"]

    # Assemble cells
    row = [
        f"{fmt_pct(gm)} {tick(gm > THRESH['gross_margin_min'])}",
        f"{fmt_pct(sga_m)} {tick(sga_m < THRESH['sga_margin_max'])}",
        f"{fmt_pct(rnd_m)} {tick(rnd_m < THRESH['rnd_margin_max'])}",
        f"{fmt_pct(dep_m)} {tick(dep_m < THRESH['depr_margin_max'])}",
        f"{fmt_pct(int_m)} {tick(int_m < THRESH['interest_margin_max'])}",
        f"{fmt_pct(tax_m)} {tick(THRESH['tax_margin_low'] <= tax_m <= THRESH['tax_margin_high'])}",
        f"{fmt_pct(net_m)} {tick(net_m > THRESH['net_margin_min'])}",
        f"{eps0:.2f} vs {eps1:.2f} {tick(eps_ok)}",
        f"Cash {fmt_billions(cash0)} vs Debt {fmt_billions(debt0)} {tick(cash_ok)}",
        f"{adj_de:.2f} {tick(adj_ok)}",
        f"{'None' if pref0==0 else f'{fmt_billions(pref0)}'} {tick(pref_ok)}",
        f"{'Up' if re_ok else 'Flat/Down'} {tick(re_ok)}",
        f"{'Yes' if tre_ok else 'No'} {tick(tre_ok)}",
        f"{fmt_pct(capex_m)} {tick(capex_ok)}"
    ]
    return row

def build_table(tickers):
    rows = [
        "Gross Margin", "SG&A Margin", "R&D Margin", "Depreciation Margin",
        "Interest Margin", "Tax Margin", "Net Income Margin", "EPS Growth",
        "Cash > Debt", "Adjusted Debt to Equity", "Preferred Stock (None)",
        "Retained Earnings Growth", "Treasury Stock (Exists)", "Capex Margin"
    ]
    data = {"Metric": rows}
    for t in tickers:
        res = compute_for_ticker(t)
        if res is not None:
            data[t] = res
        else:
            data[t] = ["N/A"] * len(rows)
    df = pd.DataFrame(data, dtype=object)
    return df

def section_summary(df, section, start, end):
    sub = df.iloc[start:end+1].copy()
    row = {"Metric": f"{section} ✓ Count"}
    for col in df.columns[1:]:
        row[col] = int(sub[col].astype(str).str.count("✓").sum())
    return pd.concat([sub, pd.DataFrame([row], dtype=object)], ignore_index=True)

def grand_total(df):
    all_rows = df.iloc[0:14]
    row = {"Metric": "TOTAL ✓ Count"}
    for col in df.columns[1:]:
        row[col] = int(all_rows[col].astype(str).str.count("✓").sum())
    return pd.DataFrame([row], dtype=object)

def assemble(df):
    income  = section_summary(df, "INCOME STATEMENT", 0, 7)
    balance = section_summary(df, "BALANCE SHEET", 8, 12)
    cash    = section_summary(df, "CASH FLOW STATEMENT", 13, 13)
    blank   = pd.DataFrame([[""] * len(df.columns)], columns=df.columns, dtype=object)
    combo   = pd.concat([income, blank, balance, blank, cash, blank, grand_total(df)], ignore_index=True)
    return combo

if __name__ == "__main__":
    df = build_table(TICKERS)
    final = assemble(df)
    print(final.to_string(index=False))
    final.to_excel("buffett_rules_yfinance.xlsx", index=False)
    print("\nSaved: buffett_rules_yfinance.xlsx")